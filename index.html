<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Realtime Christmas Pose Skeleton</title>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #020715;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    #three-container {
      position: fixed;
      inset: 0;
    }

    video {
      display: none;
    }

    #startOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 7, 21, 0.96);
      color: #fff;
      font-size: 18px;
      letter-spacing: 0.05em;
      z-index: 10;
      cursor: pointer;
      text-align: center;
      padding: 0 24px;
    }

    #startOverlay span {
      opacity: 0.8;
      font-size: 14px;
      display: block;
      margin-top: 8px;
    }

    /* é¡¶éƒ¨æ ‡é¢˜ */
    #titleBanner {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffe89a;
      font-size: 24px;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      text-shadow: 0 0 6px rgba(0, 0, 0, 0.6);
      z-index: 5;
      pointer-events: none;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <div id="three-container"></div>
  <video id="webcam" autoplay playsinline></video>

  <div id="startOverlay">
    ğŸ„ ç‚¹å‡»å±å¹•å¼€å§‹ Â· Click to start ğŸ„
    <span>ä¸¾èµ·åŒæ‰‹ï¼Œé›ªäººä¼šå¼€å¿ƒè·³èˆï¼›å¤§å®¶ä¸€èµ·è¹²ä¸‹ï¼Œé›ªäººä¼šè·ºè„š</span>
  </div>

  <div id="titleBanner">Merry Christmas 2025</div>

  <script type="module">
    /* --------- å¯¼å…¥ Three.js å’Œ MediaPipe ---------- */
    import * as THREE from "https://cdn.skypack.dev/three@0.152.2";
    import {
      PoseLandmarker,
      FilesetResolver
    } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

    /* --------- å…¨å±€çŠ¶æ€ ---------- */
    let poseLandmarker;
    let video;
    let scene, camera, renderer, skeletonRoot;
    let lastVideoTime = -1;
    let running = false;

    const SMOOTHING = 0.6;
    let previousLandmarks = [];

    // é›ªèŠ± & é›ªäººç›¸å…³
    let snow;
    let snowman;
    let snowmanLights = [];
    let snowmanHearts = [];
    let snowmanBodyMaterial = null;
    let snowmanScarfMaterial = null;

    // é›ªäººæƒ…ç»ªçŠ¶æ€
    let snowmanMood = "normal";          // "normal" | "happy"
    let snowmanMoodStrength = 0;         // 0~1ï¼Œç”¨äº happy å¹³æ»‘

    // é›ªäººè·ºè„šçŠ¶æ€
    let snowmanStompActive = false;      // æ˜¯å¦æ£€æµ‹åˆ°â€œå¤§å®¶ä¸€èµ·è¹²ä¸‹â€
    let snowmanStompStrength = 0;        // 0~1ï¼Œè·ºè„šå¼ºåº¦
    const SQUAT_HEIGHT_THRESHOLD = 0.55; // è¹²ä¸‹åˆ¤å®šé˜ˆå€¼ï¼Œè¶Šå°è¶Šâ€œè‹›åˆ»â€

    // èƒŒæ™¯éŸ³ä¹
    let bgmAudio = null;

    // å¤šäººéª¨éª¼é¢œè‰²
    const BONE_COLORS = [0x00ffff, 0xff5555, 0x55ff55];
    const JOINT_COLORS = [0xff55ff, 0xffff66, 0xffffff];

    // å½©ç¯é¢œè‰²
    const LIGHT_COLORS = [0xff6666, 0xffff99, 0x66aaff, 0xff99ff];

    // å¤´é¡¶ç¥ç¦æ–‡å­—
    const HEAD_TEXTS = ["å¹³å®‰", "å–œä¹", "å¹¸ç¦"];
    const HEAD_TEXT_COLORS = ["#ffcc66", "#ff6699", "#66ccff"];
    let headTextMaterials = [];

    // PoseLandmarker éª¨éª¼è¿çº¿
    const BONE_PAIRS = [
      [11, 12], [11, 23], [12, 24], [23, 24],
      [11, 13], [13, 15],
      [12, 14], [14, 16],
      [23, 25], [25, 27], [27, 29], [29, 31],
      [24, 26], [26, 28], [28, 30], [30, 32],
      [11, 0], [12, 0], [0, 9], [0, 10]
    ];

    const IMPORTANT_JOINTS = [
      0, 11, 12, 13, 14, 15, 16,
      23, 24, 25, 26, 27, 28,
      29, 30, 31, 32
    ];

    /* --------- å·¥å…·ï¼šæ–‡å­—æè´¨ï¼Œç”¨ä½œç¥ç¦ Sprite ---------- */
    function createTextMaterial(text, color = "#ffffff") {
      const size = 256;
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");

      ctx.clearRect(0, 0, size, size);
      ctx.font = "bold 96px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = color;
      ctx.shadowColor = "rgba(0,0,0,0.8)";
      ctx.shadowBlur = 12;
      ctx.fillText(text, size / 2, size / 2);

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return new THREE.SpriteMaterial({ map: texture, transparent: true });
    }

    function initHeadTextMaterials() {
      headTextMaterials = HEAD_TEXTS.map((txt, i) =>
        createTextMaterial(txt, HEAD_TEXT_COLORS[i % HEAD_TEXT_COLORS.length])
      );
    }

    /* --------- Helperï¼šåˆ¤æ–­å•ä¸ªäººæ˜¯å¦åœ¨â€œè¹²ä¸‹â€ ---------- */
    function isSquatting(landmarks) {
      let minY = Infinity;
      let maxY = -Infinity;
      landmarks.forEach((p) => {
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      });
      const height = maxY - minY;
      return height < SQUAT_HEIGHT_THRESHOLD;
    }

    /* --------- Three.js åˆå§‹åŒ– ---------- */
    async function initThree() {
      const container = document.getElementById("three-container");

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x071022);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.1, 10);
      camera.position.z = 2;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      skeletonRoot = new THREE.Group();
      scene.add(skeletonRoot);

      initHeadTextMaterials();
      createSnow();
      createSnowman();

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      const aspect = window.innerWidth / window.innerHeight;
      camera.left = -aspect;
      camera.right = aspect;
      camera.top = 1;
      camera.bottom = -1;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* --------- é›ªèŠ±ï¼ˆè¾ƒå¤§ï¼‰ ---------- */
    function createSnow() {
      const count = 450;
      const positions = new Float32Array(count * 3);

      for (let i = 0; i < count; i++) {
        positions[i * 3 + 0] = (Math.random() * 4 - 2);
        positions[i * 3 + 1] = (Math.random() * 3 - 1.5);
        positions[i * 3 + 2] = (Math.random() * 2 - 1);
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const mat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.13,
        sizeAttenuation: true
      });

      snow = new THREE.Points(geo, mat);
      scene.add(snow);
    }

    /* --------- å³ä¾§é›ªäºº + å½©ç¯ + çˆ±å¿ƒ ---------- */
    function createSnowman() {
      const man = new THREE.Group();

      // ä¸‰ä¸ªé›ªçƒï¼šèº«ä½“
      const bodyMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      bodyMat.userData.baseColor = new THREE.Color(0xffffff);
      snowmanBodyMaterial = bodyMat;

      const geoBottom = new THREE.SphereGeometry(0.45, 24, 24);
      const geoMiddle = new THREE.SphereGeometry(0.33, 24, 24);
      const geoHead = new THREE.SphereGeometry(0.25, 24, 24);

      const bottom = new THREE.Mesh(geoBottom, bodyMat);
      bottom.position.y = -0.9;

      const middle = new THREE.Mesh(geoMiddle, bodyMat);
      middle.position.y = -0.45;

      const head = new THREE.Mesh(geoHead, bodyMat);
      head.position.y = -0.05;

      man.add(bottom, middle, head);

      // å¸½å­
      const hatMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
      const hatBrim = new THREE.Mesh(
        new THREE.CylinderGeometry(0.28, 0.28, 0.05, 16),
        hatMat
      );
      hatBrim.position.y = 0.12;
      const hatTop = new THREE.Mesh(
        new THREE.CylinderGeometry(0.20, 0.20, 0.25, 16),
        hatMat
      );
      hatTop.position.y = 0.27;
      man.add(hatBrim, hatTop);

      // å›´å·¾
      const scarfMat = new THREE.MeshBasicMaterial({ color: 0xff5555 });
      scarfMat.userData.baseColor = new THREE.Color(0xff5555);
      snowmanScarfMaterial = scarfMat;

      const scarf = new THREE.Mesh(
        new THREE.TorusGeometry(0.26, 0.04, 12, 32),
        scarfMat
      );
      scarf.rotation.x = Math.PI / 2;
      scarf.position.y = -0.12;
      man.add(scarf);

      // é¼»å­ï¼ˆèƒ¡èåœï¼‰
      const noseMat = new THREE.MeshBasicMaterial({ color: 0xff9933 });
      const nose = new THREE.Mesh(
        new THREE.ConeGeometry(0.06, 0.18, 16),
        noseMat
      );
      nose.rotation.x = Math.PI / 2;
      nose.position.set(0, -0.02, 0.24);
      man.add(nose);

      // çœ¼ç› & å˜´å·´
      const eyeGeo = new THREE.SphereGeometry(0.03, 12, 12);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(-0.08, 0.03, 0.22);
      eyeR.position.set(0.08, 0.03, 0.22);
      man.add(eyeL, eyeR);

      const mouthGeo = new THREE.SphereGeometry(0.02, 10, 10);
      for (let i = -2; i <= 2; i++) {
        const dot = new THREE.Mesh(mouthGeo, eyeMat);
        dot.position.set(i * 0.035, -0.07, 0.22);
        man.add(dot);
      }

      // æ‰‹è‡‚ï¼ˆæœ¨æ£ï¼‰
      const armGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 8);
      const armMat = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
      const armL = new THREE.Mesh(armGeo, armMat);
      const armR = new THREE.Mesh(armGeo, armMat);
      armL.position.set(-0.55, -0.45, 0);
      armR.position.set(0.55, -0.45, 0);
      armL.rotation.z = Math.PI / 4;
      armR.rotation.z = -Math.PI / 4;
      man.add(armL, armR);

      // èº«ä¸Šçš„çº½æ‰£ / å½©ç¯ï¼ˆä¼šé—ªçƒï¼‰
      snowmanLights = [];
      const btnGeo = new THREE.SphereGeometry(0.05, 12, 12);
      for (let i = 0; i < 5; i++) {
        const baseColor = new THREE.Color(
          LIGHT_COLORS[i % LIGHT_COLORS.length]
        );
        const mat = new THREE.MeshBasicMaterial({ color: baseColor.clone() });
        const btn = new THREE.Mesh(btnGeo, mat);
        btn.position.set(
          0,
          -0.55 + i * 0.18,
          0.32
        );
        btn.userData.baseColor = baseColor;
        snowmanLights.push(btn);
        man.add(btn);
      }

      // é›ªäººå¤´é¡¶çˆ±å¿ƒé›ªçƒï¼ˆå¼€å¿ƒæ—¶æ‰å‡ºç°ï¼‰
      snowmanHearts = [];
      const heartGeo = new THREE.SphereGeometry(0.07, 16, 16);
      const heartMat = new THREE.MeshBasicMaterial({ color: 0xff77aa });
      for (let i = 0; i < 3; i++) {
        const h = new THREE.Mesh(heartGeo, heartMat);
        h.position.set((i - 1) * 0.18, 0.25, 0.28);
        h.userData.baseY = h.position.y;
        h.visible = false;
        snowmanHearts.push(h);
        man.add(h);
      }

      // æ•´ä½“ç¼©æ”¾ & æŒªåˆ°å³è¾¹
      man.scale.set(0.9, 0.9, 0.9);
      man.position.set(1.3, -0.2, -0.4);
      man.userData.baseY = man.position.y; // è®°å½•åŸºç¡€ Yï¼Œè·ºè„šæ—¶åœ¨æ­¤åŸºç¡€ä¸Šä¸Šä¸‹ç§»åŠ¨

      snowman = man;
      scene.add(man);
    }

    /* --------- MediaPipe Pose åˆå§‹åŒ– ---------- */
    async function initPoseLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );

      poseLandmarker = await PoseLandmarker.createFromOptions(
        filesetResolver,
        {
          baseOptions: {
            modelAssetPath:
              "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 4,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        }
      );
    }

    /* --------- æ‘„åƒå¤´ ---------- */
    async function setupCamera() {
      video = document.getElementById("webcam");

      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "user",
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });

      video.srcObject = stream;

      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          video.play();
          resolve();
        };
      });
    }

    /* --------- éª¨éª¼æ¸²æŸ“ ---------- */
    function clearSkeletons() {
      while (skeletonRoot.children.length) {
        const obj = skeletonRoot.children.pop();
        obj.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        skeletonRoot.remove(obj);
      }
    }

    function updateSkeletons(result) {
      clearSkeletons();

      if (!result || !result.landmarks || !result.landmarks.length) {
        snowmanMood = "normal";
        snowmanStompActive = false;
        return;
      }

      const allPoints = [];
      const aspect = window.innerWidth / window.innerHeight;

      // å¹³æ»‘å…³é”®ç‚¹
      const smoothedLandmarksArray = result.landmarks.map((poseLandmarks, i) => {
        const prev = previousLandmarks[i];

        if (prev && prev.length === poseLandmarks.length) {
          return poseLandmarks.map((p, j) => {
            const prevP = prev[j];
            return {
              x: prevP.x + SMOOTHING * (p.x - prevP.x),
              y: prevP.y + SMOOTHING * (p.y - prevP.y),
              z: prevP.z + SMOOTHING * (p.z - prevP.z),
            };
          });
        } else {
          return poseLandmarks.map((p) => ({ ...p }));
        }
      });

      previousLandmarks = smoothedLandmarksArray.map((lms) =>
        lms.map((p) => ({ ...p }))
      );

      // ====== æ£€æµ‹äº’åŠ¨åŠ¨ä½œ ======
      let anyHandsUp = false;
      let allSquatting = true;

      smoothedLandmarksArray.forEach((lms) => {
        const nose = lms[0];
        const leftWrist = lms[15];
        const rightWrist = lms[16];

        if (nose && leftWrist && rightWrist) {
          // åŒæ‰‹é«˜ä¸¾ï¼ˆä¸¤ä¸ªæ‰‹è…•éƒ½æ¯”é¼»å­æ›´é ä¸Šï¼‰
          if (leftWrist.y < nose.y - 0.05 && rightWrist.y < nose.y - 0.05) {
            anyHandsUp = true;
          }
        }

        // æ˜¯å¦è¹²ä¸‹
        if (!isSquatting(lms)) {
          allSquatting = false;
        }
      });

      snowmanMood = anyHandsUp ? "happy" : "normal";
      snowmanStompActive = allSquatting; // æ‰€æœ‰æ£€æµ‹åˆ°çš„äººéƒ½è¹²ä¸‹æ—¶è§¦å‘è·ºè„š

      // ====== ç”¨å¹³æ»‘åçš„æ•°æ®ç”»å¤šäººéª¨éª¼ ======
      smoothedLandmarksArray.forEach((poseLandmarks, idx) => {
        const group = new THREE.Group();

        const boneColor = BONE_COLORS[idx % BONE_COLORS.length];
        const jointColor = JOINT_COLORS[idx % JOINT_COLORS.length];
        const boneMaterial = new THREE.MeshBasicMaterial({ color: boneColor });
        const jointMaterial = new THREE.MeshBasicMaterial({ color: jointColor });
        const jointGeom = new THREE.SphereGeometry(0.05, 16, 16);

        const points = poseLandmarks.map((p) => {
          const x = (p.x - 0.5) * 2 * aspect;
          const y = (0.5 - p.y) * 2;
          const v = new THREE.Vector3(x, y, 0);
          allPoints.push(v);
          return v;
        });

        // éª¨éª¼çº¿
        BONE_PAIRS.forEach(([a, b]) => {
          const start = points[a];
          const end = points[b];
          if (!start || !end) return;

          const dir = new THREE.Vector3().subVectors(end, start);
          const len = dir.length();
          if (!len) return;

          const mid = start.clone().add(end).multiplyScalar(0.5);

          const geom = new THREE.CylinderGeometry(0.03, 0.03, len, 8);
          const bone = new THREE.Mesh(geom, boneMaterial);
          bone.position.copy(mid);
          bone.quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            dir.clone().normalize()
          );
          group.add(bone);
        });

        // å…³èŠ‚ç‚¹
        IMPORTANT_JOINTS.forEach((jointIndex) => {
          const p = points[jointIndex];
          if (!p) return;
          const sphere = new THREE.Mesh(jointGeom, jointMaterial);
          sphere.position.copy(p);
          group.add(sphere);
        });

        // å¤´é¡¶ç¥ç¦æ–‡å­—
        const head = points[0];
        if (head) {
          const mat = headTextMaterials[idx % headTextMaterials.length];
          const sprite = new THREE.Sprite(mat);
          sprite.position.set(head.x, head.y + 0.4, 0);
          sprite.scale.set(0.7, 0.35, 1);
          group.add(sprite);
        }

        skeletonRoot.add(group);
      });

      // è‡ªåŠ¨ç¼©æ”¾ + å±…ä¸­
      if (allPoints.length) {
        let minX = Infinity, maxX = -Infinity,
            minY = Infinity, maxY = -Infinity;

        allPoints.forEach((v) => {
          if (v.x < minX) minX = v.x;
          if (v.x > maxX) maxX = v.x;
          if (v.y < minY) minY = v.y;
          if (v.y > maxY) maxY = v.y;
        });

        const width = maxX - minX || 0.0001;
        const height = maxY - minY || 0.0001;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const target = 1.6;
        const scale = target / Math.max(width, height);

        skeletonRoot.scale.set(scale, scale, 1);
        skeletonRoot.position.set(-centerX * scale, -centerY * scale, 0);
      }
    }

    /* --------- åŠ¨ç”»ï¼šéª¨éª¼è½»å¾®æ—‹è½¬ + é›ªèŠ±é£˜è½ + é›ªäººäº’åŠ¨ ---------- */
    function animate() {
      if (!running) return;

      requestAnimationFrame(animate);

      const now = performance.now();

      // æ•´ä½“éª¨éª¼è½»å¾®å·¦å³æ‘‡æ‘†
      if (skeletonRoot) {
        skeletonRoot.rotation.y = 0.25 * Math.sin(now * 0.0004);
      }

      // é›ªèŠ±ä¸‹è½
      if (snow) {
        const positions = snow.geometry.attributes.position;
        const arr = positions.array;
        const count = arr.length / 3;

        for (let i = 0; i < count; i++) {
          let y = arr[i * 3 + 1];
          y -= 0.01;
          if (y < -1.7) y = 1.7;
          arr[i * 3 + 1] = y;
        }
        positions.needsUpdate = true;
      }

      // é›ªäººçŠ¶æ€å¹³æ»‘
      const targetHappyStrength = snowmanMood === "happy" ? 1 : 0;
      snowmanMoodStrength +=
        (targetHappyStrength - snowmanMoodStrength) * 0.06;

      const targetStompStrength = snowmanStompActive ? 1 : 0;
      snowmanStompStrength +=
        (targetStompStrength - snowmanStompStrength) * 0.18; // è·ºè„šå¯ä»¥ç¨å¿«ä¸€ç‚¹

      if (snowman) {
        // å¼€å¿ƒæ—¶å˜èƒ– + è½»å¾®â€œå‘¼å¸â€
        const baseScale = 0.9;
        const pulse = 0.05 * Math.sin(now * 0.008);
        const s =
          baseScale +
          0.08 * snowmanMoodStrength +
          pulse * snowmanMoodStrength;
        snowman.scale.set(s, s, s);

        // è·ºè„šï¼šæ•´ä½“ä¸Šä¸‹å¿«é€Ÿå°å¹…ç§»åŠ¨
        const baseY = snowman.userData.baseY ?? -0.2;
        let stompOffset = 0;
        if (snowmanStompStrength > 0.01) {
          stompOffset =
            -0.12 *
            Math.abs(Math.sin(now * 0.02)) *
            snowmanStompStrength;
        }
        snowman.position.y = baseY + stompOffset;
      }

      // èº«ä½“ä¸å›´å·¾é¢œè‰²å˜æš–ï¼ˆå¼€å¿ƒæ—¶ï¼‰
      if (snowmanBodyMaterial && snowmanBodyMaterial.userData.baseColor) {
        const base = snowmanBodyMaterial.userData.baseColor;
        const target = new THREE.Color(0xfff3f7);
        snowmanBodyMaterial.color.copy(base).lerp(target, snowmanMoodStrength);
      }
      if (snowmanScarfMaterial && snowmanScarfMaterial.userData.baseColor) {
        const base = snowmanScarfMaterial.userData.baseColor;
        const target = new THREE.Color(0xff99aa);
        snowmanScarfMaterial.color.copy(base).lerp(target, snowmanMoodStrength);
      }

      // é›ªäººèº«ä¸Šçš„å½©ç¯é—ªçƒ
      if (snowmanLights && snowmanLights.length) {
        const t = now * 0.003;
        snowmanLights.forEach((light, i) => {
          const phase = t + i * 0.6;
          let f = 0.4 + 0.6 * Math.max(0, Math.sin(phase));
          f *= 1 + 0.5 * snowmanMoodStrength; // å¼€å¿ƒæ—¶æ•´ä½“æ›´äº®
          light.material.color
            .copy(light.userData.baseColor)
            .multiplyScalar(f);
        });
      }

      // å¤´é¡¶çˆ±å¿ƒé›ªçƒï¼šå¼€å¿ƒæ—¶å‡ºç°å¹¶ä¸Šä¸‹æµ®åŠ¨
      if (snowmanHearts && snowmanHearts.length) {
        snowmanHearts.forEach((h, i) => {
          h.visible = snowmanMoodStrength > 0.15;
          if (h.visible) {
            const baseY = h.userData.baseY;
            h.position.y = baseY + 0.05 * Math.sin(now * 0.004 + i * 0.8);
          }
        });
      }

      // å…³é”®ç‚¹æ£€æµ‹ & æ¸²æŸ“
      if (poseLandmarker && video && video.readyState >= 2) {
        const nowInMs = performance.now();

        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;
          const result = poseLandmarker.detectForVideo(video, nowInMs);
          updateSkeletons(result);
        }
      }

      renderer.render(scene, camera);
    }

    /* --------- å¯åŠ¨å…¥å£ ---------- */
    async function startApp() {
      const overlay = document.getElementById("startOverlay");
      overlay.style.display = "none";

      await initThree();
      await setupCamera();
      await initPoseLandmarker();

      // èƒŒæ™¯éŸ³ä¹ï¼ˆåŒç›®å½•å‡†å¤‡ christmas.mp3ï¼‰
      try {
        bgmAudio = new Audio("christmas.mp3");
        bgmAudio.loop = true;
        bgmAudio.volume = 0.5;
        bgmAudio.play().catch((e) => {
          console.warn("èƒŒæ™¯éŸ³ä¹æ’­æ”¾è¢«æ‹¦æˆªï¼Œå¯åœ¨æ§åˆ¶å°æ‰‹åŠ¨è°ƒç”¨ bgmAudio.play()", e);
        });
      } catch (e) {
        console.warn("èƒŒæ™¯éŸ³ä¹åŠ è½½å¤±è´¥", e);
      }

      running = true;
      animate();
    }

    document
      .getElementById("startOverlay")
      .addEventListener("click", () => {
        if (!running) {
          startApp().catch((err) => {
            console.error(err);
            alert("å¯åŠ¨å¤±è´¥ï¼š" + err.message);
          });
        }
      });
  </script>
</body>
</html>
